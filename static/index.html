<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPCIS Knowledge Graph - Enhanced Interface</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .nav { background: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .nav a { margin-right: 15px; text-decoration: none; color: #007bff; font-weight: bold; }
        .nav a:hover { text-decoration: underline; }
        .page { display: none; background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .page.active { display: block; }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .metric { background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; }
        .metric-value { font-size: 2em; font-weight: bold; color: #007bff; }
        .metric-label { color: #666; margin-top: 5px; }
        .query-section { margin: 20px 0; }
        .query-input { width: 100%; height: 120px; font-family: monospace; padding: 10px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px; }
        .btn { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin-right: 10px; }
        .btn:hover { background: #0056b3; }
        .btn.secondary { background: #6c757d; }
        .btn.secondary:hover { background: #545b62; }
        .btn.success { background: #28a745; }
        .btn.success:hover { background: #218838; }
        .btn.warning { background: #ffc107; color: #212529; }
        .btn.warning:hover { background: #e0a800; }
        .results { background: #f8f9fa; padding: 15px; border-radius: 4px; margin-top: 10px; min-height: 100px; }
        .ontology-list { margin-top: 10px; }
        .ontology-item { background: #f8f9fa; padding: 15px; margin-bottom: 10px; border-radius: 4px; }
        .error { color: #dc3545; background: #f8d7da; padding: 10px; border-radius: 4px; margin: 10px 0; }
        .success { color: #155724; background: #d4edda; padding: 10px; border-radius: 4px; margin: 10px 0; }
        .loading { color: #856404; background: #fff3cd; padding: 10px; border-radius: 4px; margin: 10px 0; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background: #f8f9fa; }
        
        /* Enhanced styles for templates */
        .template-section { margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; }
        .template-buttons { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px; }
        .template-info { font-size: 0.9em; color: #666; margin-top: 5px; }
        
        /* Visualization sync controls */
        .sync-controls { 
            background: #e9ecef; 
            padding: 15px; 
            border-radius: 8px; 
            margin-bottom: 20px; 
            display: flex; 
            align-items: center; 
            gap: 15px; 
        }
        .sync-controls label { 
            display: flex; 
            align-items: center; 
            gap: 5px; 
            font-weight: bold; 
        }
        .sync-status { 
            margin-left: auto; 
            padding: 5px 10px; 
            border-radius: 4px; 
            font-size: 0.9em; 
        }
        .sync-status.active { 
            background: #d4edda; 
            color: #155724; 
        }
        .sync-status.inactive { 
            background: #f8d7da; 
            color: #721c24; 
        }
        
        /* Enhanced Results Styling */
        .no-results-enhanced {
            text-align: center;
            padding: 40px;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .no-results-icon {
            font-size: 3em;
            margin-bottom: 15px;
        }
        
        .no-results-enhanced h3 {
            color: #6c757d;
            margin-bottom: 10px;
        }
        
        .no-results-enhanced p {
            color: #6c757d;
            font-size: 0.9em;
        }
        
        .results-summary-enhanced {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .summary-header h3 {
            margin: 0 0 15px 0;
            font-size: 1.4em;
        }
        
        .result-count {
            font-size: 1.2em;
            font-weight: bold;
            color: #ffd700;
        }
        
        .query-meta {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .meta-item {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
        }
        
        .data-insights {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .insight-card {
            background: rgba(255, 255, 255, 0.15);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }
        
        .insight-card h4 {
            margin: 0 0 10px 0;
            font-size: 1em;
            opacity: 0.9;
        }
        
        .insight-content {
            font-size: 0.9em;
        }
        
        .type-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }
        
        .type-label {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .type-count {
            background: rgba(255, 255, 255, 0.3);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8em;
        }
        
        .pattern-item {
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 10px;
            border-radius: 15px;
            margin-bottom: 5px;
            font-size: 0.85em;
        }
        
        .results-table-enhanced {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .enhanced-results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9em;
        }
        
        .enhanced-results-table th {
            background: #495057;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            border: none;
        }
        
        .enhanced-results-table th small {
            color: #ced4da;
            font-weight: normal;
        }
        
        .enhanced-results-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #e9ecef;
            vertical-align: top;
        }
        
        .enhanced-row:hover {
            background: #f8f9fa;
        }
        
        .empty-value {
            color: #6c757d;
            text-align: center;
        }
        
        .empty-indicator {
            font-size: 1.2em;
            color: #adb5bd;
        }
        
        .cell-value {
            display: block;
        }
        
        .uri-value {
            word-break: break-all;
        }
        
        .uri-link {
            color: #0066cc;
            text-decoration: none;
            border-bottom: 1px dotted #0066cc;
        }
        
        .uri-link:hover {
            color: #004499;
            border-bottom-style: solid;
        }
        
        .datetime-value {
            color: #495057;
            font-family: 'Courier New', monospace;
        }
        
        .number-value {
            color: #28a745;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }
        
        .bnode-value {
            color: #6f42c1;
            font-family: 'Courier New', monospace;
        }
        
        .long-text {
            cursor: help;
            border-bottom: 1px dotted #6c757d;
        }
        
        .epcis-tag {
            background: #28a745;
            color: white;
            font-size: 0.7em;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 5px;
            vertical-align: middle;
        }
        
        /* Visualization Layout with Node Panel */
        .visualization-layout {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        
        .graph-main {
            flex: 1;
            min-width: 0;
        }
        
        .node-details-panel {
            width: 350px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
            height: fit-content;
            max-height: 700px;
            overflow-y: auto;
        }
        
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
            background: #f8f9fa;
            border-radius: 12px 12px 0 0;
        }
        
        .panel-header h3 {
            margin: 0;
            color: #495057;
            font-size: 1.1em;
        }
        
        .close-panel {
            background: none;
            border: none;
            font-size: 1.2em;
            cursor: pointer;
            color: #6c757d;
            padding: 5px;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .close-panel:hover {
            background: #e9ecef;
            color: #495057;
        }
        
        .panel-content {
            padding: 20px;
        }
        
        .no-node-selected {
            text-align: center;
            color: #6c757d;
            padding: 40px 20px;
        }
        
        .no-node-icon {
            font-size: 3em;
            margin-bottom: 15px;
            opacity: 0.5;
        }
        
        .node-details {
            animation: slideIn 0.3s ease-out;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .node-detail-section {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .node-detail-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .node-detail-label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 8px;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .node-detail-value {
            color: #212529;
            line-height: 1.5;
        }
        
        .node-type-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }
        
        .node-type-product {
            background: #e3f2fd;
            color: #1976d2;
        }
        
        .node-type-location {
            background: #f3e5f5;
            color: #7b1fa2;
        }
        
        .node-type-business {
            background: #e8f5e8;
            color: #388e3c;
        }
        
        .node-type-event {
            background: #fff3e0;
            color: #f57c00;
        }
        
        .node-type-epcis {
            background: #fce4ec;
            color: #c2185b;
        }
        
        .node-type-default {
            background: #f5f5f5;
            color: #616161;
        }
        
        .node-properties {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
        }
        
        .node-property {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .node-property:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }
        
        .node-property-key {
            font-weight: 500;
            color: #495057;
            flex: 1;
            margin-right: 10px;
        }
        
        .node-property-value {
            color: #212529;
            flex: 2;
            text-align: right;
            word-break: break-word;
        }
        
        .node-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .node-action-btn {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid #dee2e6;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            text-align: center;
            transition: all 0.2s;
        }
        
        .node-action-btn:hover {
            background: #f8f9fa;
            border-color: #adb5bd;
        }
        
        .node-action-btn.primary {
            background: #007bff;
            color: white;
            border-color: #007bff;
        }
        
        .node-action-btn.primary:hover {
            background: #0056b3;
            border-color: #0056b3;
        }
        
        /* Visualization controls */
        .visualization-controls { 
            display: flex; 
            gap: 15px; 
            margin-bottom: 20px; 
            flex-wrap: wrap; 
        }
        .control-group { 
            display: flex; 
            flex-direction: column; 
            gap: 5px; 
        }
        .control-group label { 
            font-weight: bold; 
            font-size: 0.9em; 
        }
        .control-group select, 
        .control-group input { 
            padding: 8px; 
            border: 1px solid #ddd; 
            border-radius: 4px; 
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔍 EPCIS Knowledge Graph - Enhanced Interface</h1>
            <p>Complete SPARQL query interface with synchronized visualization and template examples</p>
        </div>
        
        <div class="nav">
            <a href="#" onclick="showPage('dashboard')">Dashboard</a>
            <a href="#" onclick="showPage('query')">SPARQL Query</a>
            <a href="#" onclick="showPage('ontology')">Ontology</a>
            <a href="#" onclick="showPage('monitoring')">Monitoring</a>
            <a href="#" onclick="showPage('visualization')">Visualization</a>
        </div>
        
        <!-- Dashboard Page -->
        <div id="dashboard-page" class="page active">
            <h2>📊 Dashboard</h2>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value" id="total-triples">-</div>
                    <div class="metric-label">Total Triples</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="query-rate">-</div>
                    <div class="metric-label">Query Rate</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="memory-usage">-</div>
                    <div class="metric-label">Memory Usage</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="active-connections">-</div>
                    <div class="metric-label">Active Connections</div>
                </div>
            </div>
            <button class="btn" onclick="loadDashboardData()">Refresh Dashboard</button>
            <div id="dashboard-status"></div>
        </div>
        
        <!-- SPARQL Query Page -->
        <div id="query-page" class="page">
            <h2>🔍 SPARQL Query</h2>
            
            <!-- SPARQL Template Examples -->
            <div class="template-section">
                <h3>📋 SPARQL Template Examples</h3>
                <div class="template-buttons">
                    <button class="btn success" onclick="loadTemplate('basic')">Basic Query</button>
                    <button class="btn warning" onclick="loadTemplate('simple')">Simple Query</button>
                    <button class="btn secondary" onclick="loadTemplate('complex')">Complex Query</button>
                    <button class="btn" onclick="loadTemplate('verycomplex')">Very Complex Query</button>
                </div>
                <div class="template-info">
                    <strong>Basic:</strong> Simple triple pattern matching | 
                    <strong>Simple:</strong> Basic filtering and conditions | 
                    <strong>Complex:</strong> Joins and aggregations | 
                    <strong>Very Complex:</strong> Advanced SPARQL features
                </div>
            </div>
            
            <div class="query-section">
                <div class="query-input">
                    <textarea id="sparql-query" placeholder="Enter SPARQL query..." style="width: 100%; height: 120px; border: none; resize: none;">SELECT * WHERE { ?s ?p ?o } LIMIT 10</textarea>
                </div>
                <button class="btn" onclick="executeQuery()">Execute Query</button>
                <button class="btn secondary" onclick="clearQuery()">Clear</button>
                <button class="btn success" onclick="visualizeQueryResults()">Visualize Results</button>
            </div>
            
            <div id="query-status"></div>
            <div class="results" id="query-results">
                <p>Query results will appear here...</p>
            </div>
        </div>
        
        <!-- Ontology Page -->
        <div id="ontology-page" class="page">
            <h2>📚 Ontology Management</h2>
            <button class="btn" onclick="loadOntologyData()">Refresh Ontologies</button>
            <div id="ontology-status"></div>
            <div class="ontology-list" id="ontology-list">
                <div class="loading">Loading ontologies...</div>
            </div>
        </div>
        
        <!-- Monitoring Page -->
        <div id="monitoring-page" class="page">
            <h2>📈 Monitoring Dashboard</h2>
            <button class="btn" onclick="loadMonitoringData()">Refresh Monitoring</button>
            <div id="monitoring-status"></div>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value" id="cpu-usage">-</div>
                    <div class="metric-label">CPU Usage (%)</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="memory-mb">-</div>
                    <div class="metric-label">Memory (MB)</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="uptime">-</div>
                    <div class="metric-label">Uptime (seconds)</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="health-status">-</div>
                    <div class="metric-label">Health Status</div>
                </div>
            </div>
        </div>
        
        <!-- Visualization Page -->
        <div id="visualization-page" class="page">
            <h2>🕸️ Knowledge Graph Visualization</h2>
            
            <!-- Synchronization Controls -->
            <div class="sync-controls">
                <label>
                    <input type="checkbox" id="sync-with-query" checked>
                    Sync with SPARQL Query Tab
                </label>
                <label>
                    <input type="checkbox" id="auto-refresh" checked>
                    Auto Refresh
                </label>
                <button class="btn" onclick="refreshVisualization()">Refresh Now</button>
                <div class="sync-status active" id="sync-status">
                    ✓ Synchronized with SPARQL Query
                </div>
            </div>
            
            <!-- Visualization Controls -->
            <div class="visualization-controls">
                <div class="control-group">
                    <label for="graph-type">Graph Type:</label>
                    <select id="graph-type">
                        <option value="force">Force-Directed</option>
                        <option value="hierarchical">Hierarchical</option>
                        <option value="radial">Radial</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="node-limit">Node Limit:</label>
                    <input type="number" id="node-limit" value="15" min="5" max="50">
                </div>
                <div class="control-group">
                    <label for="layout-strength">Layout Strength:</label>
                    <input type="range" id="layout-strength" min="1" max="10" value="5">
                </div>
            </div>
            
            <button class="btn" onclick="loadVisualizationData()">Load Visualization</button>
            <div id="visualization-status"></div>
            
            <!-- Visualization Layout with Node Panel -->
            <div class="visualization-layout">
                <!-- Main Graph Container -->
                <div class="graph-main">
                    <div id="graph-container" style="width: 100%; height: 600px; border: 1px solid #ddd; margin-top: 10px;">
                        <p style="text-align: center; padding-top: 250px;">Visualization will appear here...</p>
                    </div>
                </div>
                
                <!-- Node Details Panel -->
                <div class="node-details-panel" id="node-details-panel">
                    <div class="panel-header">
                        <h3>🔍 Node Details</h3>
                        <button class="close-panel" onclick="closeNodePanel()">✕</button>
                    </div>
                    <div class="panel-content" id="node-panel-content">
                        <div class="no-node-selected">
                            <div class="no-node-icon">👆</div>
                            <p>Click on any node in the graph to view detailed information</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Load D3.js for visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <script>
        const API_BASE = '/api/v1';
        let currentQueryData = null;
        let lastQueryText = '';
        
        console.log('=== ENHANCED EPCIS KNOWLEDGE GRAPH INTERFACE LOADING ===');
        
        // SPARQL Templates
        const sparqlTemplates = {
            basic: {
                name: "Basic Query",
                description: "Simple triple pattern matching",
                query: `SELECT * WHERE { 
    ?s ?p ?o 
} LIMIT 10`
            },
            simple: {
                name: "Business Entities",
                description: "Find all business entities with their names",
                query: `SELECT ?s ?name WHERE {
    ?s <http://example.com/name> ?name 
} LIMIT 15`
            },
            complex: {
                name: "EPCIS Events",
                description: "Find EPCIS events with timestamps",
                query: `SELECT ?event ?eventTime WHERE {
    ?event <urn:epcglobal:epcis:eventTime> ?eventTime 
} LIMIT 20`
            },
            verycomplex: {
                name: "Supply Chain Flow",
                description: "Track products through supply chain events",
                query: `SELECT ?event ?disposition ?quantity WHERE {
    ?event <urn:epcglobal:epcis:disposition> ?disposition .
    ?event <urn:epcglobal:epcis:quantity> ?quantity 
} ORDER BY ?event LIMIT 25`
            }
        };
        
        // Page navigation
        function showPage(pageId) {
            console.log('Showing page:', pageId);
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId + '-page').classList.add('active');
            
            // Auto-load data for specific pages
            if (pageId === 'visualization') {
                setTimeout(() => loadVisualizationData(), 100);
            }
        }
        
        // Load SPARQL template
        function loadTemplate(templateType) {
            const template = sparqlTemplates[templateType];
            if (template) {
                document.getElementById('sparql-query').value = template.query;
                console.log(`Loaded ${template.name}: ${template.description}`);
                
                // Update status
                const statusDiv = document.getElementById('query-status');
                statusDiv.innerHTML = `<div class="success">✅ Loaded ${template.name}: ${template.description}</div>`;
                
                // Auto-execute after a short delay
                setTimeout(() => {
                    executeQuery();
                }, 500);
            }
        }
        
        // Dashboard functions
        async function loadDashboardData() {
            console.log('Loading dashboard data...');
            const statusDiv = document.getElementById('dashboard-status');
            statusDiv.innerHTML = '<div class="loading">Loading dashboard data...</div>';
            
            try {
                const response = await fetch(`${API_BASE}/statistics`);
                console.log('Statistics response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Statistics data:', data);
                
                // Update dashboard metrics
                document.getElementById('total-triples').textContent = data.total_triples || 0;
                document.getElementById('query-rate').textContent = '0';
                document.getElementById('memory-usage').textContent = `${data.memory_usage_mb || 0} MB`;
                document.getElementById('active-connections').textContent = '1';
                
                statusDiv.innerHTML = '<div class="success">✅ Dashboard data loaded successfully</div>';
                
            } catch (error) {
                console.error('Dashboard loading failed:', error);
                statusDiv.innerHTML = `<div class="error">❌ Failed to load dashboard: ${error.message}</div>`;
            }
        }
        
        // SPARQL Query functions
        async function executeQuery() {
            console.log('Executing SPARQL query...');
            const queryInput = document.getElementById('sparql-query');
            const query = queryInput.value.trim();
            const statusDiv = document.getElementById('query-status');
            const resultsDiv = document.getElementById('query-results');
            
            if (!query) {
                statusDiv.innerHTML = '<div class="error">❌ Please enter a SPARQL query</div>';
                return;
            }
            
            statusDiv.innerHTML = '<div class="loading">Executing query...</div>';
            resultsDiv.innerHTML = '<div class="loading">Processing results...</div>';
            
            try {
                const response = await fetch(`${API_BASE}/sparql/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        query: query,
                        default_graph_uri: null,
                        named_graph_uri: null
                    })
                });
                
                console.log('SPARQL response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('SPARQL response data:', data);
                
                // Store query data for visualization
                currentQueryData = data;
                lastQueryText = query;
                
                const resultCount = data.results && data.results.bindings ? data.results.bindings.length : 0;
                
                statusDiv.innerHTML = `<div class="success">✅ Query executed successfully - ${resultCount} results found</div>`;
                
                // Display enhanced results
                if (resultCount === 0) {
                    resultsDiv.innerHTML = '<div class="no-results-enhanced"><div class="no-results-icon">📭</div><h3>No Results Found</h3><p>Try adjusting your query or check the data structure.</p></div>';
                } else {
                    resultsDiv.innerHTML = formatEnhancedSparqlResults(data);
                }
                
                // Auto-sync with visualization if enabled
                if (document.getElementById('sync-with-query').checked) {
                    setTimeout(() => {
                        updateVisualizationFromQuery();
                    }, 1000);
                }
                
            } catch (error) {
                console.error('Query execution failed:', error);
                statusDiv.innerHTML = `<div class="error">❌ Query failed: ${error.message}</div>`;
                resultsDiv.innerHTML = '<div class="error">Failed to execute query</div>';
            }
        }
        
        // Enhanced SPARQL results formatting
        function formatEnhancedSparqlResults(data) {
            if (!data.results || !data.results.bindings || data.results.bindings.length === 0) {
                return '<div class="no-results-enhanced"><div class="no-results-icon">📭</div><h3>No Results Found</h3><p>Try adjusting your query or check the data structure.</p></div>';
            }
            
            const vars = data.head.vars;
            const bindings = data.results.bindings;
            
            // Enhanced results summary with intelligence
            let html = '<div class="results-summary-enhanced">';
            html += `<div class="summary-header">`;
            html += `<h3><span class="result-count">${bindings.length}</span> Results Found</h3>`;
            html += `<div class="query-meta">`;
            html += `<span class="meta-item"><strong>Variables:</strong> ${vars.length}</span>`;
            html += `<span class="meta-item"><strong>Query Type:</strong> ${getQueryTypeDescription(data.query_type || 'SELECT')}</span>`;
            if (data.execution_time_ms) {
                html += `<span class="meta-item"><strong>Execution Time:</strong> ${data.execution_time_ms}ms</span>`;
            }
            html += `</div>`;
            html += `</div>`;
            
            // Data insights
            html += `<div class="data-insights">`;
            html += generateDataInsights(bindings, vars);
            html += `</div>`;
            html += '</div>';
            
            // Enhanced table with better formatting
            html += '<div class="results-table-enhanced">';
            html += '<table class="enhanced-results-table"><thead><tr>';
            vars.forEach(v => {
                html += `<th>${getVariableDisplayName(v)}${getVarDescription(v)}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            bindings.forEach((binding, index) => {
                html += `<tr class="result-row enhanced-row" data-index="${index}">`;
                vars.forEach(v => {
                    const value = binding[v];
                    if (value) {
                        html += `<td>${formatEnhancedCellValue(value, v, binding)}</td>`;
                    } else {
                        html += '<td class="empty-value"><span class="empty-indicator">∅</span></td>';
                    }
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            html += '</div>';
            
            return html;
        }
        
        // Generate intelligent data insights
        function generateDataInsights(bindings, vars) {
            const insights = [];
            
            // Analyze data types
            const typeCounts = {};
            bindings.forEach(binding => {
                vars.forEach(v => {
                    if (binding[v]) {
                        const type = binding[v].type || 'unknown';
                        typeCounts[type] = (typeCounts[type] || 0) + 1;
                    }
                });
            });
            
            insights.push(`<div class="insight-card">`);
            insights.push(`<h4>📊 Data Composition</h4>`);
            insights.push(`<div class="insight-content">`);
            Object.entries(typeCounts).forEach(([type, count]) => {
                const percentage = Math.round((count / (bindings.length * vars.length)) * 100);
                insights.push(`<div class="type-stat"><span class="type-label">${getTypeIcon(type)} ${type}</span><span class="type-count">${count} (${percentage}%)</span></div>`);
            });
            insights.push(`</div></div>`);
            
            // Detect EPCIS patterns
            const epcisPatterns = detectEpcisPatterns(bindings, vars);
            if (epcisPatterns.length > 0) {
                insights.push(`<div class="insight-card">`);
                insights.push(`<h4>🏭 EPCIS Patterns Detected</h4>`);
                insights.push(`<div class="insight-content">`);
                epcisPatterns.forEach(pattern => {
                    insights.push(`<div class="pattern-item">${pattern}</div>`);
                });
                insights.push(`</div></div>`);
            }
            
            return insights.join('');
        }
        
        // Detect EPCIS data patterns
        function detectEpcisPatterns(bindings, vars) {
            const patterns = [];
            
            // Check for supply chain entities
            const hasProducts = bindings.some(b => 
                Object.values(b).some(v => 
                    v.value.includes('product') || v.value.includes('EPC')
                )
            );
            
            const hasEvents = bindings.some(b => 
                Object.values(b).some(v => 
                    v.value.includes('event') || v.value.includes('Event')
                )
            );
            
            const hasLocations = bindings.some(b => 
                Object.values(b).some(v => 
                    v.value.includes('location') || v.value.includes('bizLocation')
                )
            );
            
            if (hasProducts) patterns.push('📦 Product/Entity data');
            if (hasEvents) patterns.push('📅 Event/Temporal data');
            if (hasLocations) patterns.push('📍 Location/Spatial data');
            
            // Check for business relationships
            const hasBusinessEntities = bindings.some(b => 
                Object.values(b).some(v => 
                    v.value.includes('business') || v.value.includes('manufacturer')
                )
            );
            
            if (hasBusinessEntities) patterns.push('🏢 Business Entities');
            
            return patterns;
        }
        
        // Get type icon for better visual representation
        function getTypeIcon(type) {
            const icons = {
                'uri': '🔗',
                'literal': '📝',
                'bnode': '⚪',
                'typed-literal': '🏷️'
            };
            return icons[type] || '❓';
        }
        
        // Get query type description
        function getQueryTypeDescription(queryType) {
            const descriptions = {
                'SELECT': 'Data Retrieval',
                'CONSTRUCT': 'Graph Construction',
                'ASK': 'Boolean Query',
                'DESCRIBE': 'Resource Description'
            };
            return descriptions[queryType] || queryType;
        }
        
        // Get variable display name with user-friendly formatting
        function getVariableDisplayName(variable) {
            const nameMap = {
                's': 'Subject',
                'p': 'Predicate', 
                'o': 'Object',
                'g': 'Graph',
                'name': 'Name',
                'event': 'Event',
                'eventTime': 'Event Time',
                'disposition': 'Disposition',
                'quantity': 'Quantity',
                'location': 'Location',
                'type': 'Type'
            };
            
            return nameMap[variable] || variable;
        }
        
        // Get variable description for better understanding
        function getVarDescription(variable) {
            const descriptions = {
                's': '<br><small>Resource identifier</small>',
                'p': '<br><small>Relationship/Property</small>',
                'o': '<br><small>Value/Resource</small>',
                'g': '<br><small>Named graph</small>',
                'name': '<br><small>Entity name</small>',
                'event': '<br><small>EPCIS event</small>',
                'eventTime': '<br><small>Timestamp</small>',
                'disposition': '<br><small>Business step</small>',
                'quantity': '<br><small>Amount/Count</small>',
                'location': '<br><small>Place/Position</small>',
                'type': '<br><small>Classification</small>'
            };
            
            return descriptions[variable] || '';
        }
        
        // Format enhanced cell value with intelligence
        function formatEnhancedCellValue(value, variable, binding) {
            if (!value) return '<span class="empty-indicator">∅</span>';
            
            let displayValue = value.value;
            let className = 'cell-value';
            
            // Add type-specific formatting
            switch (value.type) {
                case 'uri':
                    // Shorten URIs for better display
                    if (value.value.length > 60) {
                        displayValue = value.value.substring(0, 57) + '...';
                    }
                    displayValue = `<a href="${value.value}" target="_blank" class="uri-link" title="${value.value}">${displayValue}</a>`;
                    className += ' uri-value';
                    break;
                    
                case 'literal':
                    // Special formatting for different literal types
                    if (variable.includes('time') || variable.includes('date')) {
                        displayValue = formatDateTime(value.value);
                        className += ' datetime-value';
                    } else if (variable.includes('quantity') || variable.includes('count')) {
                        displayValue = formatNumber(value.value);
                        className += ' number-value';
                    } else if (value.value.length > 50) {
                        displayValue = `<span class="long-text" title="${value.value}">${value.value.substring(0, 47)}...</span>`;
                    }
                    break;
                    
                case 'bnode':
                    displayValue = `_:${value.value}`;
                    className += ' bnode-value';
                    break;
            }
            
            // Add EPCIS-specific intelligence
            if (value.value.includes('epcis') || value.value.includes('EPCIS')) {
                displayValue += ' <span class="epcis-tag">EPCIS</span>';
            }
            
            return `<span class="${className}">${displayValue}</span>`;
        }
        
        // Format date/time for better readability
        function formatDateTime(dateTimeStr) {
            try {
                const date = new Date(dateTimeStr);
                if (isNaN(date.getTime())) return dateTimeStr;
                return date.toLocaleString();
            } catch (e) {
                return dateTimeStr;
            }
        }
        
        // Format numbers for better readability
        function formatNumber(numStr) {
            try {
                const num = parseFloat(numStr);
                if (isNaN(num)) return numStr;
                return num.toLocaleString();
            } catch (e) {
                return numStr;
            }
        }
        
        // Visualize query results
        function visualizeQueryResults() {
            if (!currentQueryData) {
                alert('Please execute a query first to visualize its results');
                return;
            }
            
            // Switch to visualization page
            showPage('visualization');
            
            // Update visualization with query results
            setTimeout(() => {
                updateVisualizationFromQuery();
            }, 100);
        }
        
        // Update visualization from current query
        async function updateVisualizationFromQuery() {
            if (!currentQueryData || !currentQueryData.results) {
                console.log('No query data available for visualization');
                return;
            }
            
            console.log('🔄 Updating visualization from query results...');
            const statusDiv = document.getElementById('visualization-status');
            const containerDiv = document.getElementById('graph-container');
            
            statusDiv.innerHTML = '<div class="loading">🔄 Visualizing query results...</div>';
            
            try {
                const bindings = currentQueryData.results.bindings;
                if (!bindings || bindings.length === 0) {
                    throw new Error('No data available for visualization');
                }
                
                console.log(`🔍 Converting ${bindings.length} query results to graph format...`);
                const graphData = convertSparqlToGraph(bindings);
                
                if (graphData.nodes.length === 0) {
                    throw new Error('No nodes could be created from the query results');
                }
                
                console.log(`📈 Graph has ${graphData.nodes.length} nodes and ${graphData.links.length} links`);
                
                // Create D3.js visualization
                createKnowledgeGraphVisualization(containerDiv, graphData);
                
                statusDiv.innerHTML = `<div class="success">✅ Visualization updated from query results - ${graphData.nodes.length} nodes, ${graphData.links.length} relationships</div>`;
                
                // Update sync status
                const syncStatus = document.getElementById('sync-status');
                syncStatus.textContent = '✓ Synchronized with SPARQL Query';
                syncStatus.className = 'sync-status active';
                
            } catch (error) {
                console.error('❌ Query visualization failed:', error);
                statusDiv.innerHTML = `<div class="error">❌ Failed to visualize query results: ${error.message}</div>`;
                containerDiv.innerHTML = `<div class="error">❌ Failed to visualize query results: ${error.message}</div>`;
            }
        }
        
        function clearQuery() {
            document.getElementById('sparql-query').value = 'SELECT * WHERE { ?s ?p ?o } LIMIT 10';
            document.getElementById('query-status').innerHTML = '';
            document.getElementById('query-results').innerHTML = '<p>Query results will appear here...</p>';
            currentQueryData = null;
        }
        
        // Ontology functions
        async function loadOntologyData() {
            console.log('Loading ontology data...');
            const statusDiv = document.getElementById('ontology-status');
            const listDiv = document.getElementById('ontology-list');
            
            statusDiv.innerHTML = '<div class="loading">Loading ontology data...</div>';
            listDiv.innerHTML = '<div class="loading">Processing ontologies...</div>';
            
            try {
                const response = await fetch(`${API_BASE}/ontologies`);
                console.log('Ontology response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Ontology data:', data);
                
                const ontologies = data.ontologies || [];
                
                if (ontologies.length === 0) {
                    listDiv.innerHTML = '<p>No ontologies loaded</p>';
                } else {
                    let html = '';
                    ontologies.forEach(ont => {
                        html += `
                            <div class="ontology-item">
                                <div><strong>${ont.name}</strong></div>
                                <div>Triples: ${ont.triples || 0}</div>
                                <div>Status: ${ont.loaded ? '✓ Loaded' : '❌ Not loaded'}</div>
                            </div>
                        `;
                    });
                    listDiv.innerHTML = html;
                }
                
                statusDiv.innerHTML = `<div class="success">✅ Loaded ${ontologies.length} ontologies</div>`;
                
            } catch (error) {
                console.error('Ontology loading failed:', error);
                statusDiv.innerHTML = `<div class="error">❌ Failed to load ontologies: ${error.message}</div>`;
                listDiv.innerHTML = '<div class="error">Failed to load ontologies</div>';
            }
        }
        
        // Monitoring functions
        async function loadMonitoringData() {
            console.log('Loading monitoring data...');
            const statusDiv = document.getElementById('monitoring-status');
            
            statusDiv.innerHTML = '<div class="loading">Loading monitoring data...</div>';
            
            try {
                const response = await fetch(`${API_BASE}/monitoring/health`);
                console.log('Monitoring response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Monitoring data:', data);
                
                // Update monitoring metrics
                document.getElementById('cpu-usage').textContent = `${data.cpu_usage_percent || 0}%`;
                document.getElementById('memory-mb').textContent = `${data.memory_usage_mb || 0}`;
                document.getElementById('uptime').textContent = data.uptime_seconds || 0;
                document.getElementById('health-status').textContent = data.status || 'unknown';
                
                statusDiv.innerHTML = '<div class="success">✅ Monitoring data loaded successfully</div>';
                
            } catch (error) {
                console.error('Monitoring loading failed:', error);
                statusDiv.innerHTML = `<div class="error">❌ Failed to load monitoring: ${error.message}</div>`;
            }
        }
        
        // Visualization functions
        async function loadVisualizationData() {
            console.log('🚀 Loading visualization data...');
            const statusDiv = document.getElementById('visualization-status');
            const containerDiv = document.getElementById('graph-container');
            
            statusDiv.innerHTML = '<div class="loading">🔄 Loading visualization data...</div>';
            
            try {
                // Get node limit from controls
                const nodeLimit = parseInt(document.getElementById('node-limit').value);
                
                // Get real SPARQL data for visualization
                const response = await fetch(`${API_BASE}/sparql/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        query: `SELECT * WHERE { ?s ?p ?o } LIMIT ${nodeLimit}`,
                        default_graph_uri: null,
                        named_graph_uri: null
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('✅ SPARQL API Response received');
                
                if (!data.results || !data.results.bindings) {
                    throw new Error('No data available for visualization');
                }
                
                console.log(`🔍 Converting ${data.results.bindings.length} SPARQL results to graph format...`);
                // Convert SPARQL results to graph format
                const graphData = convertSparqlToGraph(data.results.bindings);
                
                if (graphData.nodes.length === 0) {
                    throw new Error('No nodes could be created from the SPARQL results');
                }
                
                console.log(`📈 Graph has ${graphData.nodes.length} nodes and ${graphData.links.length} links`);
                
                // Create D3.js visualization
                createKnowledgeGraphVisualization(containerDiv, graphData);
                
                statusDiv.innerHTML = `<div class="success">✅ Visualization loaded successfully - ${graphData.nodes.length} nodes, ${graphData.links.length} relationships</div>`;
                
            } catch (error) {
                console.error('❌ Visualization loading failed:', error);
                statusDiv.innerHTML = `<div class="error">❌ Failed to load visualization: ${error.message}</div>`;
                containerDiv.innerHTML = `<div class="error">❌ Failed to load visualization: ${error.message}</div>`;
            }
        }
        
        // Refresh visualization
        function refreshVisualization() {
            loadVisualizationData();
        }
        
        // Convert SPARQL results to graph format
        function convertSparqlToGraph(bindings) {
            console.log('🔄 Converting SPARQL bindings to graph...');
            const nodes = new Map();
            const links = [];
            
            bindings.forEach((binding, index) => {
                const subject = binding.s?.value;
                const predicate = binding.p?.value;
                const object = binding.o?.value;
                
                if (subject && predicate && object) {
                    // Add subject node if not exists
                    if (!nodes.has(subject)) {
                        nodes.set(subject, {
                            id: subject,
                            name: getNodeName(subject),
                            type: getNodeType(subject),
                            group: getNodeGroup(subject)
                        });
                    }
                    
                    // Add object node if not exists
                    if (!nodes.has(object)) {
                        nodes.set(object, {
                            id: object,
                            name: getNodeName(object),
                            type: getNodeType(object),
                            group: getNodeGroup(object)
                        });
                    }
                    
                    // Add link
                    links.push({
                        source: subject,
                        target: object,
                        type: getEdgeType(predicate),
                        label: getEdgeLabel(predicate)
                    });
                }
            });
            
            const result = {
                nodes: Array.from(nodes.values()),
                links: links
            };
            
            console.log(`✅ Conversion complete: ${result.nodes.length} nodes, ${result.links.length} links`);
            return result;
        }
        
        // Helper functions for node and edge processing
        function getNodeName(uri) {
            if (uri.startsWith('ex:')) {
                return uri.replace('ex:', '').replace(/resource\d+/, 'Resource').replace(/(\d+)/, ' $1');
            }
            if (uri.includes('#')) {
                return uri.split('#').pop();
            }
            if (uri.includes('/')) {
                return uri.split('/').pop();
            }
            return uri.length > 30 ? uri.substring(0, 30) + '...' : uri;
        }
        
        function getNodeType(uri) {
            if (uri.includes('Product') || uri.includes('product')) return 'product';
            if (uri.includes('Location') || uri.includes('location')) return 'location';
            if (uri.includes('Event') || uri.includes('event')) return 'event';
            if (uri.includes('Business') || uri.includes('business')) return 'business';
            return 'resource';
        }
        
        function getNodeGroup(uri) {
            const type = getNodeType(uri);
            switch (type) {
                case 'product': return 1;
                case 'location': return 2;
                case 'event': return 3;
                case 'business': return 4;
                default: return 0;
            }
        }
        
        function getEdgeType(predicate) {
            if (predicate.includes('type')) return 'type';
            if (predicate.includes('has')) return 'has';
            if (predicate.includes('located')) return 'location';
            if (predicate.includes('involved')) return 'involvement';
            return 'relationship';
        }
        
        function getEdgeLabel(predicate) {
            if (predicate.includes('#')) {
                return predicate.split('#').pop();
            }
            return predicate.length > 20 ? predicate.substring(0, 20) + '...' : predicate;
        }
        
        // Create D3.js knowledge graph visualization
        function createKnowledgeGraphVisualization(container, data) {
            // Clear container
            container.innerHTML = '';
            
            // Set up dimensions
            const width = container.clientWidth;
            const height = 600;
            const margin = 40;
            
            // Get layout strength from controls
            const layoutStrength = parseInt(document.getElementById('layout-strength').value);
            
            // Create SVG
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Create zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // Create main group
            const g = svg.append('g');
            
            // Add click handler to background (empty space) to close node panel
            svg.on('click', function(event) {
                // Only close if clicking directly on the SVG background (not on nodes or links)
                if (event.target === this) {
                    closeNodePanel();
                }
            });
            
            // Create color scale
            const color = d3.scaleOrdinal(d3.schemeCategory10);
            
            // Create force simulation with configurable strength
            const simulation = d3.forceSimulation(data.nodes)
                .force('link', d3.forceLink(data.links).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-300 * (layoutStrength / 5)))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(25));
            
            // Create links
            const link = g.append('g')
                .selectAll('line')
                .data(data.links)
                .enter().append('line')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', 2);
            
            // Add link labels
            const linkLabels = g.append('g')
                .selectAll('text')
                .data(data.links)
                .enter().append('text')
                .attr('font-size', '10px')
                .attr('fill', '#666')
                .attr('text-anchor', 'middle')
                .text(d => d.label);
            
            // Create nodes
            const node = g.append('g')
                .selectAll('g')
                .data(data.nodes)
                .enter().append('g')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('click', function(event, d) {
                    // Prevent event propagation and handle node click
                    event.stopPropagation();
                    console.log('🔍 Node clicked:', d);
                    showNodeDetails(d);
                    
                    // Visual feedback for clicked node
                    d3.select(this).select('circle')
                        .transition()
                        .duration(200)
                        .attr('r', 16)
                        .transition()
                        .duration(200)
                        .attr('r', 12);
                });
            
            // Add circles to nodes
            node.append('circle')
                .attr('r', 12)
                .attr('fill', d => color(d.group))
                .attr('stroke', '#fff')
                .attr('stroke-width', 2);
            
            // Add labels to nodes
            node.append('text')
                .attr('dx', 15)
                .attr('dy', 4)
                .attr('font-size', '12px')
                .attr('fill', '#333')
                .text(d => d.name);
            
            // Add tooltips
            node.append('title')
                .text(d => `${d.name} (${d.type})`);
            
            // Update positions on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                linkLabels
                    .attr('x', d => (d.source.x + d.target.x) / 2)
                    .attr('y', d => (d.source.y + d.target.y) / 2);
                
                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });
            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // Add legend
            const legend = svg.append('g')
                .attr('transform', `translate(${width - 150}, 20)`);
            
            const nodeTypes = [...new Set(data.nodes.map(n => n.type))];
            nodeTypes.forEach((type, i) => {
                const legendItem = legend.append('g')
                    .attr('transform', `translate(0, ${i * 25})`);
                
                legendItem.append('circle')
                    .attr('r', 6)
                    .attr('fill', color(i + 1));
                
                legendItem.append('text')
                    .attr('x', 15)
                    .attr('y', 4)
                    .attr('font-size', '12px')
                    .text(type.charAt(0).toUpperCase() + type.slice(1));
            });
            
            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 20)
                .attr('text-anchor', 'middle')
                .attr('font-size', '16px')
                .attr('font-weight', 'bold')
                .text('Knowledge Graph Visualization');
                
            // Store reference to current graph data for node interactions
            window.currentGraphData = data;
        }
        
        // Node interaction functions
        function showNodeDetails(nodeData) {
            console.log('🔍 Showing node details for:', nodeData);
            
            const panel = document.getElementById('node-details-panel');
            const content = document.getElementById('node-panel-content');
            
            // Generate node type badge
            const typeClass = getNodeBadgeClass(nodeData.type);
            const typeBadge = `<span class="node-type-badge ${typeClass}">${nodeData.type}</span>`;
            
            // Generate node properties from connections
            const properties = generateNodeProperties(nodeData);
            
            // Generate node description
            const description = generateNodeDescription(nodeData);
            
            content.innerHTML = `
                <div class="node-details">
                    <div class="node-detail-section">
                        <div class="node-detail-label">Entity Type</div>
                        <div class="node-detail-value">
                            ${typeBadge}
                        </div>
                    </div>
                    
                    <div class="node-detail-section">
                        <div class="node-detail-label">Name</div>
                        <div class="node-detail-value">
                            <strong>${escapeHtml(nodeData.name)}</strong>
                        </div>
                    </div>
                    
                    <div class="node-detail-section">
                        <div class="node-detail-label">Description</div>
                        <div class="node-detail-value">
                            ${description}
                        </div>
                    </div>
                    
                    <div class="node-detail-section">
                        <div class="node-detail-label">Identifier</div>
                        <div class="node-detail-value">
                            <code style="font-size: 0.85em; word-break: break-all;">${escapeHtml(nodeData.id)}</code>
                        </div>
                    </div>
                    
                    ${properties.length > 0 ? `
                    <div class="node-detail-section">
                        <div class="node-detail-label">Connected Properties</div>
                        <div class="node-properties">
                            ${properties.map(prop => `
                                <div class="node-property">
                                    <div class="node-property-key">${escapeHtml(prop.key)}</div>
                                    <div class="node-property-value">${escapeHtml(prop.value)}</div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                    ` : ''}
                    
                    <div class="node-detail-section">
                        <div class="node-detail-label">Actions</div>
                        <div class="node-actions">
                            <button class="node-action-btn" onclick="findRelatedNodes('${escapeHtml(nodeData.id)}')">
                                🔍 Find Related
                            </button>
                            <button class="node-action-btn primary" onclick="centerOnNode('${escapeHtml(nodeData.id)}')">
                                🎯 Center in Graph
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Ensure panel is visible
            panel.style.display = 'block';
        }
        
        function closeNodePanel() {
            const panel = document.getElementById('node-details-panel');
            const content = document.getElementById('node-panel-content');
            
            content.innerHTML = `
                <div class="no-node-selected">
                    <div class="no-node-icon">👆</div>
                    <p>Click on any node in the graph to view detailed information</p>
                </div>
            `;
        }
        
        function getNodeBadgeClass(type) {
            const typeMap = {
                'product': 'node-type-product',
                'location': 'node-type-location', 
                'business': 'node-type-business',
                'manufacturer': 'node-type-business',
                'event': 'node-type-event',
                'epcis': 'node-type-epcis'
            };
            return typeMap[type.toLowerCase()] || 'node-type-default';
        }
        
        function generateNodeProperties(nodeData) {
            if (!window.currentGraphData) return [];
            
            const properties = [];
            const links = window.currentGraphData.links;
            
            // Find all connections for this node
            links.forEach(link => {
                if (link.source === nodeData.id || link.source.id === nodeData.id) {
                    const targetNode = typeof link.target === 'object' ? link.target : 
                        window.currentGraphData.nodes.find(n => n.id === link.target);
                    
                    if (targetNode && targetNode.id !== nodeData.id) {
                        properties.push({
                            key: link.label || 'connected to',
                            value: targetNode.name
                        });
                    }
                }
                
                if (link.target === nodeData.id || link.target.id === nodeData.id) {
                    const sourceNode = typeof link.source === 'object' ? link.source :
                        window.currentGraphData.nodes.find(n => n.id === link.source);
                    
                    if (sourceNode && sourceNode.id !== nodeData.id) {
                        properties.push({
                            key: `connected from ${link.label || 'source'}`,
                            value: sourceNode.name
                        });
                    }
                }
            });
            
            // Remove duplicates and limit to top 10
            const uniqueProps = [];
            const seen = new Set();
            
            properties.forEach(prop => {
                const key = `${prop.key}-${prop.value}`;
                if (!seen.has(key) && uniqueProps.length < 10) {
                    seen.add(key);
                    uniqueProps.push(prop);
                }
            });
            
            return uniqueProps;
        }
        
        function generateNodeDescription(nodeData) {
            const type = nodeData.type.toLowerCase();
            const name = nodeData.name;
            
            const descriptions = {
                'product': `This is a product entity in the supply chain. Products track items as they move through various stages of manufacturing and distribution.`,
                'location': `This represents a physical location in the supply chain, such as a factory, warehouse, or retail store.`,
                'business': `This is a business entity involved in the supply chain, such as a manufacturer, distributor, or retailer.`,
                'manufacturer': `A manufacturer that creates products in the supply chain.`,
                'event': `An EPCIS event that records a specific occurrence in the supply chain, such as shipping, receiving, or inventory changes.`,
                'epcis': `An EPCIS (Electronic Product Code Information Services) entity that tracks product movement and status.`
            };
            
            const baseDescription = descriptions[type] || `This is a ${type} entity in the knowledge graph representing part of the supply chain network.`;
            
            // Add specific information based on the node name
            if (name && name !== type) {
                return `${baseDescription} This specific entity is identified as "${name}".`;
            }
            
            return baseDescription;
        }
        
        function findRelatedNodes(nodeId) {
            if (!window.currentGraphData) return;
            
            // Find nodes connected to the specified node
            const relatedNodes = new Set();
            const relatedLinks = [];
            
            window.currentGraphData.links.forEach(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                
                if (sourceId === nodeId || targetId === nodeId) {
                    relatedNodes.add(sourceId);
                    relatedNodes.add(targetId);
                    relatedLinks.push(link);
                }
            });
            
            // Highlight related nodes in the graph (this would require additional graph manipulation)
            console.log(`🔍 Found ${relatedNodes.size - 1} related nodes and ${relatedLinks.length} connections for node: ${nodeId}`);
            
            // Show a temporary message
            const content = document.getElementById('node-panel-content');
            const originalContent = content.innerHTML;
            
            content.innerHTML = `
                <div style="text-align: center; padding: 20px; color: #28a745;">
                    <div style="font-size: 2em; margin-bottom: 10px;">🔍</div>
                    <p>Found <strong>${relatedNodes.size - 1}</strong> related nodes connected to this entity</p>
                    <p style="font-size: 0.9em; color: #6c757d; margin-top: 10px;">(Graph highlighting would be implemented in a full version)</p>
                    <button onclick="this.parentElement.parentElement.innerHTML = \`${originalContent.replace(/`/g, '\\`')}\`" 
                            style="margin-top: 15px; padding: 8px 16px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">
                        Back to Details
                    </button>
                </div>
            `;
        }
        
        function centerOnNode(nodeId) {
            // This would require access to the D3.js simulation and node objects
            // For now, show a message indicating the functionality
            console.log(`🎯 Centering on node: ${nodeId}`);
            
            const content = document.getElementById('node-panel-content');
            const originalContent = content.innerHTML;
            
            content.innerHTML = `
                <div style="text-align: center; padding: 20px; color: #007bff;">
                    <div style="font-size: 2em; margin-bottom: 10px;">🎯</div>
                    <p>Centering graph on selected node</p>
                    <p style="font-size: 0.9em; color: #6c757d; margin-top: 10px;">(Graph centering would be implemented in a full version)</p>
                    <button onclick="this.parentElement.parentElement.innerHTML = \`${originalContent.replace(/`/g, '\\`')}\`" 
                            style="margin-top: 15px; padding: 8px 16px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; cursor: pointer;">
                        Back to Details
                    </button>
                </div>
            `;
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Auto-refresh functionality
        function setupAutoRefresh() {
            const autoRefreshCheckbox = document.getElementById('auto-refresh');
            if (autoRefreshCheckbox && autoRefreshCheckbox.checked) {
                setInterval(() => {
                    const currentPage = document.querySelector('.page.active');
                    if (currentPage && currentPage.id === 'visualization-page') {
                        refreshVisualization();
                    }
                }, 30000); // Refresh every 30 seconds
            }
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('=== ENHANCED EPCIS KNOWLEDGE GRAPH INITIALIZING ===');
            
            // Load initial data
            loadDashboardData();
            loadOntologyData();
            loadMonitoringData();
            
            // Setup event listeners
            document.getElementById('sync-with-query').addEventListener('change', function() {
                const syncStatus = document.getElementById('sync-status');
                if (this.checked) {
                    syncStatus.textContent = '✓ Synchronized with SPARQL Query';
                    syncStatus.className = 'sync-status active';
                } else {
                    syncStatus.textContent = '⚠ Not synchronized with SPARQL Query';
                    syncStatus.className = 'sync-status inactive';
                }
            });
            
            // Setup auto-refresh
            setupAutoRefresh();
            
            // Auto-load visualization data
            setTimeout(() => {
                console.log('Auto-loading visualization data...');
                loadVisualizationData();
            }, 1000); // Wait 1 second to ensure other data is loaded first
            
            console.log('✅ Enhanced EPCIS Knowledge Graph initialized successfully');
        });
    </script>
</body>
</html>