<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EPCIS Knowledge Graph - Enhanced Interface</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .nav { background: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .nav a { margin-right: 15px; text-decoration: none; color: #007bff; font-weight: bold; }
        .nav a:hover { text-decoration: underline; }
        .page { display: none; background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .page.active { display: block; }
        .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 20px; }
        .metric { background: #f8f9fa; padding: 20px; border-radius: 8px; text-align: center; }
        .metric-value { font-size: 2em; font-weight: bold; color: #007bff; }
        .metric-label { color: #666; margin-top: 5px; }
        .query-section { margin: 20px 0; }
        .query-input { width: 100%; height: 120px; font-family: monospace; padding: 10px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px; }
        .btn { background: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; margin-right: 10px; }
        .btn:hover { background: #0056b3; }
        .btn.secondary { background: #6c757d; }
        .btn.secondary:hover { background: #545b62; }
        .btn.success { background: #28a745; }
        .btn.success:hover { background: #218838; }
        .btn.warning { background: #ffc107; color: #212529; }
        .btn.warning:hover { background: #e0a800; }
        .results { background: #f8f9fa; padding: 15px; border-radius: 4px; margin-top: 10px; min-height: 100px; }
        .ontology-list { margin-top: 10px; }
        .ontology-item { background: #f8f9fa; padding: 15px; margin-bottom: 10px; border-radius: 4px; }
        .error { color: #dc3545; background: #f8d7da; padding: 10px; border-radius: 4px; margin: 10px 0; }
        .success { color: #155724; background: #d4edda; padding: 10px; border-radius: 4px; margin: 10px 0; }
        .loading { color: #856404; background: #fff3cd; padding: 10px; border-radius: 4px; margin: 10px 0; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background: #f8f9fa; }
        
        /* Enhanced styles for templates */
        .template-section { margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px; }
        .template-buttons { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 15px; }
        .template-info { font-size: 0.9em; color: #666; margin-top: 5px; }
        
        /* Visualization sync controls */
        .sync-controls { 
            background: #e9ecef; 
            padding: 15px; 
            border-radius: 8px; 
            margin-bottom: 20px; 
            display: flex; 
            align-items: center; 
            gap: 15px; 
        }
        .sync-controls label { 
            display: flex; 
            align-items: center; 
            gap: 5px; 
            font-weight: bold; 
        }
        .sync-status { 
            margin-left: auto; 
            padding: 5px 10px; 
            border-radius: 4px; 
            font-size: 0.9em; 
        }
        .sync-status.active { 
            background: #d4edda; 
            color: #155724; 
        }
        .sync-status.inactive { 
            background: #f8d7da; 
            color: #721c24; 
        }
        
        /* Visualization controls */
        .visualization-controls { 
            display: flex; 
            gap: 15px; 
            margin-bottom: 20px; 
            flex-wrap: wrap; 
        }
        .control-group { 
            display: flex; 
            flex-direction: column; 
            gap: 5px; 
        }
        .control-group label { 
            font-weight: bold; 
            font-size: 0.9em; 
        }
        .control-group select, 
        .control-group input { 
            padding: 8px; 
            border: 1px solid #ddd; 
            border-radius: 4px; 
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç EPCIS Knowledge Graph - Enhanced Interface</h1>
            <p>Complete SPARQL query interface with synchronized visualization and template examples</p>
        </div>
        
        <div class="nav">
            <a href="#" onclick="showPage('dashboard')">Dashboard</a>
            <a href="#" onclick="showPage('query')">SPARQL Query</a>
            <a href="#" onclick="showPage('ontology')">Ontology</a>
            <a href="#" onclick="showPage('monitoring')">Monitoring</a>
            <a href="#" onclick="showPage('visualization')">Visualization</a>
        </div>
        
        <!-- Dashboard Page -->
        <div id="dashboard-page" class="page active">
            <h2>üìä Dashboard</h2>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value" id="total-triples">-</div>
                    <div class="metric-label">Total Triples</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="query-rate">-</div>
                    <div class="metric-label">Query Rate</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="memory-usage">-</div>
                    <div class="metric-label">Memory Usage</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="active-connections">-</div>
                    <div class="metric-label">Active Connections</div>
                </div>
            </div>
            <button class="btn" onclick="loadDashboardData()">Refresh Dashboard</button>
            <div id="dashboard-status"></div>
        </div>
        
        <!-- SPARQL Query Page -->
        <div id="query-page" class="page">
            <h2>üîç SPARQL Query</h2>
            
            <!-- SPARQL Template Examples -->
            <div class="template-section">
                <h3>üìã SPARQL Template Examples</h3>
                <div class="template-buttons">
                    <button class="btn success" onclick="loadTemplate('basic')">Basic Query</button>
                    <button class="btn warning" onclick="loadTemplate('simple')">Simple Query</button>
                    <button class="btn secondary" onclick="loadTemplate('complex')">Complex Query</button>
                    <button class="btn" onclick="loadTemplate('verycomplex')">Very Complex Query</button>
                </div>
                <div class="template-info">
                    <strong>Basic:</strong> Simple triple pattern matching | 
                    <strong>Simple:</strong> Basic filtering and conditions | 
                    <strong>Complex:</strong> Joins and aggregations | 
                    <strong>Very Complex:</strong> Advanced SPARQL features
                </div>
            </div>
            
            <div class="query-section">
                <div class="query-input">
                    <textarea id="sparql-query" placeholder="Enter SPARQL query..." style="width: 100%; height: 120px; border: none; resize: none;">SELECT * WHERE { ?s ?p ?o } LIMIT 10</textarea>
                </div>
                <button class="btn" onclick="executeQuery()">Execute Query</button>
                <button class="btn secondary" onclick="clearQuery()">Clear</button>
                <button class="btn success" onclick="visualizeQueryResults()">Visualize Results</button>
            </div>
            
            <div id="query-status"></div>
            <div class="results" id="query-results">
                <p>Query results will appear here...</p>
            </div>
        </div>
        
        <!-- Ontology Page -->
        <div id="ontology-page" class="page">
            <h2>üìö Ontology Management</h2>
            <button class="btn" onclick="loadOntologyData()">Refresh Ontologies</button>
            <div id="ontology-status"></div>
            <div class="ontology-list" id="ontology-list">
                <div class="loading">Loading ontologies...</div>
            </div>
        </div>
        
        <!-- Monitoring Page -->
        <div id="monitoring-page" class="page">
            <h2>üìà Monitoring Dashboard</h2>
            <button class="btn" onclick="loadMonitoringData()">Refresh Monitoring</button>
            <div id="monitoring-status"></div>
            <div class="metrics">
                <div class="metric">
                    <div class="metric-value" id="cpu-usage">-</div>
                    <div class="metric-label">CPU Usage (%)</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="memory-mb">-</div>
                    <div class="metric-label">Memory (MB)</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="uptime">-</div>
                    <div class="metric-label">Uptime (seconds)</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="health-status">-</div>
                    <div class="metric-label">Health Status</div>
                </div>
            </div>
        </div>
        
        <!-- Visualization Page -->
        <div id="visualization-page" class="page">
            <h2>üï∏Ô∏è Knowledge Graph Visualization</h2>
            
            <!-- Synchronization Controls -->
            <div class="sync-controls">
                <label>
                    <input type="checkbox" id="sync-with-query" checked>
                    Sync with SPARQL Query Tab
                </label>
                <label>
                    <input type="checkbox" id="auto-refresh" checked>
                    Auto Refresh
                </label>
                <button class="btn" onclick="refreshVisualization()">Refresh Now</button>
                <div class="sync-status active" id="sync-status">
                    ‚úì Synchronized with SPARQL Query
                </div>
            </div>
            
            <!-- Visualization Controls -->
            <div class="visualization-controls">
                <div class="control-group">
                    <label for="graph-type">Graph Type:</label>
                    <select id="graph-type">
                        <option value="force">Force-Directed</option>
                        <option value="hierarchical">Hierarchical</option>
                        <option value="radial">Radial</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="node-limit">Node Limit:</label>
                    <input type="number" id="node-limit" value="15" min="5" max="50">
                </div>
                <div class="control-group">
                    <label for="layout-strength">Layout Strength:</label>
                    <input type="range" id="layout-strength" min="1" max="10" value="5">
                </div>
            </div>
            
            <button class="btn" onclick="loadVisualizationData()">Load Visualization</button>
            <div id="visualization-status"></div>
            <div id="graph-container" style="width: 100%; height: 600px; border: 1px solid #ddd; margin-top: 10px;">
                <p style="text-align: center; padding-top: 250px;">Visualization will appear here...</p>
            </div>
        </div>
    </div>
    
    <!-- Load D3.js for visualization -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <script>
        const API_BASE = '/api/v1';
        let currentQueryData = null;
        let lastQueryText = '';
        
        console.log('=== ENHANCED EPCIS KNOWLEDGE GRAPH INTERFACE LOADING ===');
        
        // SPARQL Templates
        const sparqlTemplates = {
            basic: {
                name: "Basic Query",
                description: "Simple triple pattern matching",
                query: `SELECT * WHERE { 
    ?s ?p ?o 
} LIMIT 10`
            },
            simple: {
                name: "Business Entities",
                description: "Find all business entities with their names",
                query: `SELECT ?s ?name WHERE {
    ?s <http://example.com/name> ?name 
} LIMIT 15`
            },
            complex: {
                name: "EPCIS Events",
                description: "Find EPCIS events with timestamps",
                query: `SELECT ?event ?eventTime WHERE {
    ?event <urn:epcglobal:epcis:eventTime> ?eventTime 
} LIMIT 20`
            },
            verycomplex: {
                name: "Supply Chain Flow",
                description: "Track products through supply chain events",
                query: `SELECT ?event ?disposition ?quantity WHERE {
    ?event <urn:epcglobal:epcis:disposition> ?disposition .
    ?event <urn:epcglobal:epcis:quantity> ?quantity 
} ORDER BY ?event LIMIT 25`
            }
        };
        
        // Page navigation
        function showPage(pageId) {
            console.log('Showing page:', pageId);
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId + '-page').classList.add('active');
            
            // Auto-load data for specific pages
            if (pageId === 'visualization') {
                setTimeout(() => loadVisualizationData(), 100);
            }
        }
        
        // Load SPARQL template
        function loadTemplate(templateType) {
            const template = sparqlTemplates[templateType];
            if (template) {
                document.getElementById('sparql-query').value = template.query;
                console.log(`Loaded ${template.name}: ${template.description}`);
                
                // Update status
                const statusDiv = document.getElementById('query-status');
                statusDiv.innerHTML = `<div class="success">‚úÖ Loaded ${template.name}: ${template.description}</div>`;
                
                // Auto-execute after a short delay
                setTimeout(() => {
                    executeQuery();
                }, 500);
            }
        }
        
        // Dashboard functions
        async function loadDashboardData() {
            console.log('Loading dashboard data...');
            const statusDiv = document.getElementById('dashboard-status');
            statusDiv.innerHTML = '<div class="loading">Loading dashboard data...</div>';
            
            try {
                const response = await fetch(`${API_BASE}/statistics`);
                console.log('Statistics response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Statistics data:', data);
                
                // Update dashboard metrics
                document.getElementById('total-triples').textContent = data.total_triples || 0;
                document.getElementById('query-rate').textContent = '0';
                document.getElementById('memory-usage').textContent = `${data.memory_usage_mb || 0} MB`;
                document.getElementById('active-connections').textContent = '1';
                
                statusDiv.innerHTML = '<div class="success">‚úÖ Dashboard data loaded successfully</div>';
                
            } catch (error) {
                console.error('Dashboard loading failed:', error);
                statusDiv.innerHTML = `<div class="error">‚ùå Failed to load dashboard: ${error.message}</div>`;
            }
        }
        
        // SPARQL Query functions
        async function executeQuery() {
            console.log('Executing SPARQL query...');
            const queryInput = document.getElementById('sparql-query');
            const query = queryInput.value.trim();
            const statusDiv = document.getElementById('query-status');
            const resultsDiv = document.getElementById('query-results');
            
            if (!query) {
                statusDiv.innerHTML = '<div class="error">‚ùå Please enter a SPARQL query</div>';
                return;
            }
            
            statusDiv.innerHTML = '<div class="loading">Executing query...</div>';
            resultsDiv.innerHTML = '<div class="loading">Processing results...</div>';
            
            try {
                const response = await fetch(`${API_BASE}/sparql/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        query: query,
                        default_graph_uri: null,
                        named_graph_uri: null
                    })
                });
                
                console.log('SPARQL response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('SPARQL response data:', data);
                
                // Store query data for visualization
                currentQueryData = data;
                lastQueryText = query;
                
                const resultCount = data.results && data.results.bindings ? data.results.bindings.length : 0;
                
                statusDiv.innerHTML = `<div class="success">‚úÖ Query executed successfully - ${resultCount} results found</div>`;
                
                // Display results
                if (resultCount === 0) {
                    resultsDiv.innerHTML = '<p>No results found</p>';
                } else {
                    let tableHtml = '<table><thead><tr>';
                    const vars = data.head.vars;
                    vars.forEach(v => {
                        tableHtml += `<th>${v}</th>`;
                    });
                    tableHtml += '</tr></thead><tbody>';
                    
                    data.results.bindings.forEach(binding => {
                        tableHtml += '<tr>';
                        vars.forEach(v => {
                            const value = binding[v];
                            if (value) {
                                let displayValue = value.value;
                                if (value.type === 'uri') {
                                    displayValue = `<a href="${value.value}" target="_blank">${value.value}</a>`;
                                }
                                tableHtml += `<td>${displayValue}</td>`;
                            } else {
                                tableHtml += '<td>-</td>';
                            }
                        });
                        tableHtml += '</tr>';
                    });
                    
                    tableHtml += '</tbody></table>';
                    resultsDiv.innerHTML = tableHtml;
                }
                
                // Auto-sync with visualization if enabled
                if (document.getElementById('sync-with-query').checked) {
                    setTimeout(() => {
                        updateVisualizationFromQuery();
                    }, 1000);
                }
                
            } catch (error) {
                console.error('Query execution failed:', error);
                statusDiv.innerHTML = `<div class="error">‚ùå Query failed: ${error.message}</div>`;
                resultsDiv.innerHTML = '<div class="error">Failed to execute query</div>';
            }
        }
        
        // Visualize query results
        function visualizeQueryResults() {
            if (!currentQueryData) {
                alert('Please execute a query first to visualize its results');
                return;
            }
            
            // Switch to visualization page
            showPage('visualization');
            
            // Update visualization with query results
            setTimeout(() => {
                updateVisualizationFromQuery();
            }, 100);
        }
        
        // Update visualization from current query
        async function updateVisualizationFromQuery() {
            if (!currentQueryData || !currentQueryData.results) {
                console.log('No query data available for visualization');
                return;
            }
            
            console.log('üîÑ Updating visualization from query results...');
            const statusDiv = document.getElementById('visualization-status');
            const containerDiv = document.getElementById('graph-container');
            
            statusDiv.innerHTML = '<div class="loading">üîÑ Visualizing query results...</div>';
            
            try {
                const bindings = currentQueryData.results.bindings;
                if (!bindings || bindings.length === 0) {
                    throw new Error('No data available for visualization');
                }
                
                console.log(`üîç Converting ${bindings.length} query results to graph format...`);
                const graphData = convertSparqlToGraph(bindings);
                
                if (graphData.nodes.length === 0) {
                    throw new Error('No nodes could be created from the query results');
                }
                
                console.log(`üìà Graph has ${graphData.nodes.length} nodes and ${graphData.links.length} links`);
                
                // Create D3.js visualization
                createKnowledgeGraphVisualization(containerDiv, graphData);
                
                statusDiv.innerHTML = `<div class="success">‚úÖ Visualization updated from query results - ${graphData.nodes.length} nodes, ${graphData.links.length} relationships</div>`;
                
                // Update sync status
                const syncStatus = document.getElementById('sync-status');
                syncStatus.textContent = '‚úì Synchronized with SPARQL Query';
                syncStatus.className = 'sync-status active';
                
            } catch (error) {
                console.error('‚ùå Query visualization failed:', error);
                statusDiv.innerHTML = `<div class="error">‚ùå Failed to visualize query results: ${error.message}</div>`;
                containerDiv.innerHTML = `<div class="error">‚ùå Failed to visualize query results: ${error.message}</div>`;
            }
        }
        
        function clearQuery() {
            document.getElementById('sparql-query').value = 'SELECT * WHERE { ?s ?p ?o } LIMIT 10';
            document.getElementById('query-status').innerHTML = '';
            document.getElementById('query-results').innerHTML = '<p>Query results will appear here...</p>';
            currentQueryData = null;
        }
        
        // Ontology functions
        async function loadOntologyData() {
            console.log('Loading ontology data...');
            const statusDiv = document.getElementById('ontology-status');
            const listDiv = document.getElementById('ontology-list');
            
            statusDiv.innerHTML = '<div class="loading">Loading ontology data...</div>';
            listDiv.innerHTML = '<div class="loading">Processing ontologies...</div>';
            
            try {
                const response = await fetch(`${API_BASE}/ontologies`);
                console.log('Ontology response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Ontology data:', data);
                
                const ontologies = data.ontologies || [];
                
                if (ontologies.length === 0) {
                    listDiv.innerHTML = '<p>No ontologies loaded</p>';
                } else {
                    let html = '';
                    ontologies.forEach(ont => {
                        html += `
                            <div class="ontology-item">
                                <div><strong>${ont.name}</strong></div>
                                <div>Triples: ${ont.triples || 0}</div>
                                <div>Status: ${ont.loaded ? '‚úì Loaded' : '‚ùå Not loaded'}</div>
                            </div>
                        `;
                    });
                    listDiv.innerHTML = html;
                }
                
                statusDiv.innerHTML = `<div class="success">‚úÖ Loaded ${ontologies.length} ontologies</div>`;
                
            } catch (error) {
                console.error('Ontology loading failed:', error);
                statusDiv.innerHTML = `<div class="error">‚ùå Failed to load ontologies: ${error.message}</div>`;
                listDiv.innerHTML = '<div class="error">Failed to load ontologies</div>';
            }
        }
        
        // Monitoring functions
        async function loadMonitoringData() {
            console.log('Loading monitoring data...');
            const statusDiv = document.getElementById('monitoring-status');
            
            statusDiv.innerHTML = '<div class="loading">Loading monitoring data...</div>';
            
            try {
                const response = await fetch(`${API_BASE}/monitoring/health`);
                console.log('Monitoring response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('Monitoring data:', data);
                
                // Update monitoring metrics
                document.getElementById('cpu-usage').textContent = `${data.cpu_usage_percent || 0}%`;
                document.getElementById('memory-mb').textContent = `${data.memory_usage_mb || 0}`;
                document.getElementById('uptime').textContent = data.uptime_seconds || 0;
                document.getElementById('health-status').textContent = data.status || 'unknown';
                
                statusDiv.innerHTML = '<div class="success">‚úÖ Monitoring data loaded successfully</div>';
                
            } catch (error) {
                console.error('Monitoring loading failed:', error);
                statusDiv.innerHTML = `<div class="error">‚ùå Failed to load monitoring: ${error.message}</div>`;
            }
        }
        
        // Visualization functions
        async function loadVisualizationData() {
            console.log('üöÄ Loading visualization data...');
            const statusDiv = document.getElementById('visualization-status');
            const containerDiv = document.getElementById('graph-container');
            
            statusDiv.innerHTML = '<div class="loading">üîÑ Loading visualization data...</div>';
            
            try {
                // Get node limit from controls
                const nodeLimit = parseInt(document.getElementById('node-limit').value);
                
                // Get real SPARQL data for visualization
                const response = await fetch(`${API_BASE}/sparql/query`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        query: `SELECT * WHERE { ?s ?p ?o } LIMIT ${nodeLimit}`,
                        default_graph_uri: null,
                        named_graph_uri: null
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('‚úÖ SPARQL API Response received');
                
                if (!data.results || !data.results.bindings) {
                    throw new Error('No data available for visualization');
                }
                
                console.log(`üîç Converting ${data.results.bindings.length} SPARQL results to graph format...`);
                // Convert SPARQL results to graph format
                const graphData = convertSparqlToGraph(data.results.bindings);
                
                if (graphData.nodes.length === 0) {
                    throw new Error('No nodes could be created from the SPARQL results');
                }
                
                console.log(`üìà Graph has ${graphData.nodes.length} nodes and ${graphData.links.length} links`);
                
                // Create D3.js visualization
                createKnowledgeGraphVisualization(containerDiv, graphData);
                
                statusDiv.innerHTML = `<div class="success">‚úÖ Visualization loaded successfully - ${graphData.nodes.length} nodes, ${graphData.links.length} relationships</div>`;
                
            } catch (error) {
                console.error('‚ùå Visualization loading failed:', error);
                statusDiv.innerHTML = `<div class="error">‚ùå Failed to load visualization: ${error.message}</div>`;
                containerDiv.innerHTML = `<div class="error">‚ùå Failed to load visualization: ${error.message}</div>`;
            }
        }
        
        // Refresh visualization
        function refreshVisualization() {
            loadVisualizationData();
        }
        
        // Convert SPARQL results to graph format
        function convertSparqlToGraph(bindings) {
            console.log('üîÑ Converting SPARQL bindings to graph...');
            const nodes = new Map();
            const links = [];
            
            bindings.forEach((binding, index) => {
                const subject = binding.s?.value;
                const predicate = binding.p?.value;
                const object = binding.o?.value;
                
                if (subject && predicate && object) {
                    // Add subject node if not exists
                    if (!nodes.has(subject)) {
                        nodes.set(subject, {
                            id: subject,
                            name: getNodeName(subject),
                            type: getNodeType(subject),
                            group: getNodeGroup(subject)
                        });
                    }
                    
                    // Add object node if not exists
                    if (!nodes.has(object)) {
                        nodes.set(object, {
                            id: object,
                            name: getNodeName(object),
                            type: getNodeType(object),
                            group: getNodeGroup(object)
                        });
                    }
                    
                    // Add link
                    links.push({
                        source: subject,
                        target: object,
                        type: getEdgeType(predicate),
                        label: getEdgeLabel(predicate)
                    });
                }
            });
            
            const result = {
                nodes: Array.from(nodes.values()),
                links: links
            };
            
            console.log(`‚úÖ Conversion complete: ${result.nodes.length} nodes, ${result.links.length} links`);
            return result;
        }
        
        // Helper functions for node and edge processing
        function getNodeName(uri) {
            if (uri.startsWith('ex:')) {
                return uri.replace('ex:', '').replace(/resource\d+/, 'Resource').replace(/(\d+)/, ' $1');
            }
            if (uri.includes('#')) {
                return uri.split('#').pop();
            }
            if (uri.includes('/')) {
                return uri.split('/').pop();
            }
            return uri.length > 30 ? uri.substring(0, 30) + '...' : uri;
        }
        
        function getNodeType(uri) {
            if (uri.includes('Product') || uri.includes('product')) return 'product';
            if (uri.includes('Location') || uri.includes('location')) return 'location';
            if (uri.includes('Event') || uri.includes('event')) return 'event';
            if (uri.includes('Business') || uri.includes('business')) return 'business';
            return 'resource';
        }
        
        function getNodeGroup(uri) {
            const type = getNodeType(uri);
            switch (type) {
                case 'product': return 1;
                case 'location': return 2;
                case 'event': return 3;
                case 'business': return 4;
                default: return 0;
            }
        }
        
        function getEdgeType(predicate) {
            if (predicate.includes('type')) return 'type';
            if (predicate.includes('has')) return 'has';
            if (predicate.includes('located')) return 'location';
            if (predicate.includes('involved')) return 'involvement';
            return 'relationship';
        }
        
        function getEdgeLabel(predicate) {
            if (predicate.includes('#')) {
                return predicate.split('#').pop();
            }
            return predicate.length > 20 ? predicate.substring(0, 20) + '...' : predicate;
        }
        
        // Create D3.js knowledge graph visualization
        function createKnowledgeGraphVisualization(container, data) {
            // Clear container
            container.innerHTML = '';
            
            // Set up dimensions
            const width = container.clientWidth;
            const height = 600;
            const margin = 40;
            
            // Get layout strength from controls
            const layoutStrength = parseInt(document.getElementById('layout-strength').value);
            
            // Create SVG
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Create zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // Create main group
            const g = svg.append('g');
            
            // Create color scale
            const color = d3.scaleOrdinal(d3.schemeCategory10);
            
            // Create force simulation with configurable strength
            const simulation = d3.forceSimulation(data.nodes)
                .force('link', d3.forceLink(data.links).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-300 * (layoutStrength / 5)))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(25));
            
            // Create links
            const link = g.append('g')
                .selectAll('line')
                .data(data.links)
                .enter().append('line')
                .attr('stroke', '#999')
                .attr('stroke-opacity', 0.6)
                .attr('stroke-width', 2);
            
            // Add link labels
            const linkLabels = g.append('g')
                .selectAll('text')
                .data(data.links)
                .enter().append('text')
                .attr('font-size', '10px')
                .attr('fill', '#666')
                .attr('text-anchor', 'middle')
                .text(d => d.label);
            
            // Create nodes
            const node = g.append('g')
                .selectAll('g')
                .data(data.nodes)
                .enter().append('g')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // Add circles to nodes
            node.append('circle')
                .attr('r', 12)
                .attr('fill', d => color(d.group))
                .attr('stroke', '#fff')
                .attr('stroke-width', 2);
            
            // Add labels to nodes
            node.append('text')
                .attr('dx', 15)
                .attr('dy', 4)
                .attr('font-size', '12px')
                .attr('fill', '#333')
                .text(d => d.name);
            
            // Add tooltips
            node.append('title')
                .text(d => `${d.name} (${d.type})`);
            
            // Update positions on tick
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                linkLabels
                    .attr('x', d => (d.source.x + d.target.x) / 2)
                    .attr('y', d => (d.source.y + d.target.y) / 2);
                
                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });
            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // Add legend
            const legend = svg.append('g')
                .attr('transform', `translate(${width - 150}, 20)`);
            
            const nodeTypes = [...new Set(data.nodes.map(n => n.type))];
            nodeTypes.forEach((type, i) => {
                const legendItem = legend.append('g')
                    .attr('transform', `translate(0, ${i * 25})`);
                
                legendItem.append('circle')
                    .attr('r', 6)
                    .attr('fill', color(i + 1));
                
                legendItem.append('text')
                    .attr('x', 15)
                    .attr('y', 4)
                    .attr('font-size', '12px')
                    .text(type.charAt(0).toUpperCase() + type.slice(1));
            });
            
            // Add title
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 20)
                .attr('text-anchor', 'middle')
                .attr('font-size', '16px')
                .attr('font-weight', 'bold')
                .text('Knowledge Graph Visualization');
        }
        
        // Auto-refresh functionality
        function setupAutoRefresh() {
            const autoRefreshCheckbox = document.getElementById('auto-refresh');
            if (autoRefreshCheckbox && autoRefreshCheckbox.checked) {
                setInterval(() => {
                    const currentPage = document.querySelector('.page.active');
                    if (currentPage && currentPage.id === 'visualization-page') {
                        refreshVisualization();
                    }
                }, 30000); // Refresh every 30 seconds
            }
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            console.log('=== ENHANCED EPCIS KNOWLEDGE GRAPH INITIALIZING ===');
            
            // Load initial data
            loadDashboardData();
            loadOntologyData();
            loadMonitoringData();
            
            // Setup event listeners
            document.getElementById('sync-with-query').addEventListener('change', function() {
                const syncStatus = document.getElementById('sync-status');
                if (this.checked) {
                    syncStatus.textContent = '‚úì Synchronized with SPARQL Query';
                    syncStatus.className = 'sync-status active';
                } else {
                    syncStatus.textContent = '‚ö† Not synchronized with SPARQL Query';
                    syncStatus.className = 'sync-status inactive';
                }
            });
            
            // Setup auto-refresh
            setupAutoRefresh();
            
            // Auto-load visualization data
            setTimeout(() => {
                console.log('Auto-loading visualization data...');
                loadVisualizationData();
            }, 1000); // Wait 1 second to ensure other data is loaded first
            
            console.log('‚úÖ Enhanced EPCIS Knowledge Graph initialized successfully');
        });
    </script>
</body>
</html>